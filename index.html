<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Farm Royale ‚Äî Mobile</title>
<style>
  :root{
    --pad: 10px;
    --card-w: clamp(88px, 22vw, 120px);
    --card-h: clamp(116px, 30vw, 160px);
    --hud-w: min(1024px, 98vw);
    --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  html, body { height:100%; margin:0; background:#0e0f14; font-family: var(--font); color:#fff; }
  .wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:var(--pad); padding-bottom: calc(env(safe-area-inset-bottom, 0px) + var(--pad)); }
  #game { background:#7dcf7d; border-radius:12px; box-shadow: 0 12px 40px rgba(0,0,0,.35); touch-action:none; width: 100%; height: auto; max-width: 1024px; aspect-ratio: 16 / 9; }
  .hud { width:var(--hud-w); display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
  .hud .left, .hud .right { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .stat { background:#1a1d25; padding:6px 10px; border-radius:8px; font-weight:600; font-size: clamp(12px, 2.8vw, 14px); }
  .manaBar { position:relative; width: clamp(180px, 40vw, 260px); height:16px; background:#10131a; border-radius:10px; overflow:hidden; }
  .manaFill { position:absolute; top:0; left:0; height:100%; background:linear-gradient(90deg, #53a2ff, #94d0ff); width:0%; transition: width .15s linear; }
  .cards { width:var(--hud-w); display:flex; justify-content:flex-start; gap:10px; user-select:none; -webkit-user-select:none; overflow-x:auto; padding-bottom:6px; }
  .cards::-webkit-scrollbar{ height:8px; }
  .cards::-webkit-scrollbar-thumb{ background:#2a3244; border-radius:8px; }
  .card { flex:0 0 var(--card-w); height:var(--card-h); background:#1b2230; border-radius:12px; box-shadow: 0 10px 20px rgba(0,0,0,.35); position:relative; cursor:grab; transform: translateZ(0); }
  .card.dragging { opacity:.85; transform: scale(1.04); }
  .cardTitle { position:absolute; top:6px; left:8px; right:8px; font-size: clamp(12px, 3.2vw, 14px); font-weight:800; text-shadow:0 2px 0 rgba(0,0,0,.2); }
  .cost { position:absolute; bottom:6px; right:8px; background:#0f1730; padding:4px 8px; border-radius:10px; font-weight:900; font-size: clamp(12px, 3.2vw, 14px); }
  .disabled { filter: grayscale(0.9) brightness(0.6); }
  .toast { position:fixed; bottom:calc(env(safe-area-inset-bottom, 0px) + 16px); left:50%; transform:translateX(-50%); background:#111826; padding:10px 14px; border-radius:10px; opacity:0; transition:opacity .25s; pointer-events:none; max-width: 92vw; text-align:center; }
  .toast.show { opacity:1; }
  .btnRow { display:flex; gap:6px; }
  .btn { background:#243047; border:none; color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:800; font-size: clamp(12px, 3vw, 14px); }
  .btn.primary { background:#3a7ef5; }
  .endScreen { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); }
  .endCard { background:#121620; padding:20px; border-radius:16px; text-align:center; box-shadow: 0 20px 50px rgba(0,0,0,.5); width:min(440px, 92vw); }
  .endCard h1 { margin:0 0 6px; font-size: clamp(20px, 6vw, 32px); }
  .endCard p { opacity:.95; font-size: clamp(14px, 3.8vw, 16px); }
  .endCard .btnRow { margin-top:12px; justify-content:center; }
  .hint { width:var(--hud-w); font-size: clamp(12px, 3.2vw, 14px); opacity:.8; text-align:center; }
  @media (orientation:portrait){
    #game { aspect-ratio: 16/9; }
  }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="1024" height="576"></canvas>
  <div class="hud">
    <div class="left">
      <div class="stat">‚è± <span id="timer">3:00</span></div>
      <div class="stat">üëë You: <span id="pCrowns">0</span></div>
      <div class="stat">ü§ñ AI: <span id="eCrowns">0</span></div>
    </div>
    <div class="right">
      <div class="manaBar" title="Mana">
        <div class="manaFill" id="manaFill"></div>
      </div>
      <div class="stat">üîÆ <span id="manaText">5 / 10</span></div>
      <div class="btnRow">
        <button class="btn" id="reduceMotionBtn">Reduce Motion: Auto</button>
        <button class="btn" id="muteBtn">Mute: Off</button>
      </div>
    </div>
  </div>
  <div class="hint">Tip: drag a card onto the left half of the battlefield to deploy. Pinch zoom is disabled while dragging.</div>
  <div class="cards" id="cardRow"></div>
</div>

<div class="endScreen" id="endScreen">
  <div class="endCard">
    <h1 id="endTitle">Victory!</h1>
    <p id="endSummary">You 1 ‚Äî 0 AI</p>
    <div class="btnRow">
      <button class="btn primary" id="restartBtn">Restart</button>
    </div>
  </div>
</div>

<div class="toast" id="toast">Not enough mana!</div>

<!-- Embedded SVG assets as data URIs -->
<script>
const SVGs = {
  banana: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><defs><linearGradient id="g" x1="0" x2="1"><stop stop-color="#fff176"/><stop offset="1" stop-color="#fbc02d"/></linearGradient></defs><path d="M10 44 C 18 40, 30 54, 52 50 C 40 58, 18 58, 10 44 Z" fill="url(#g)" stroke="#8d6e63" stroke-width="2"/><circle cx="24" cy="48" r="3" fill="#000"/><circle cx="34" cy="50" r="3" fill="#000"/></svg>`),
  carrot: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><defs><linearGradient id="o" x1="0" x2="0" y1="0" y2="1"><stop stop-color="#ff8a65"/><stop offset="1" stop-color="#e65100"/></linearGradient></defs><path d="M32 4 L44 16 L32 60 L20 16 Z" fill="url(#o)" stroke="#6d4c41" stroke-width="2"/><path d="M22 10 C20 4, 26 6, 28 8 C30 10, 34 6, 36 8 C38 10, 38 12, 36 14" fill="none" stroke="#66bb6a" stroke-width="4"/><circle cx="28" cy="28" r="3" fill="#000"/><circle cx="36" cy="30" r="3" fill="#000"/></svg>`),
  tomato: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="32" cy="36" r="22" fill="#ef5350" stroke="#b71c1c" stroke-width="3"/><path d="M20 16 C24 8, 40 8, 44 16 C36 18, 28 18, 20 16 Z" fill="#66bb6a" stroke="#2e7d32" stroke-width="2"/><circle cx="26" cy="36" r="3" fill="#000"/><circle cx="38" cy="38" r="3" fill="#000"/></svg>`),
  pineapple: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><ellipse cx="32" cy="38" rx="18" ry="22" fill="#ffca28" stroke="#e65100" stroke-width="3"/><rect x="14" y="16" width="36" height="4" fill="#43a047"/><rect x="18" y="10" width="28" height="6" fill="#66bb6a"/><circle cx="24" cy="36" r="3" fill="#000"/><circle cx="40" cy="38" r="3" fill="#000"/></svg>`),
  broccoli: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="24" cy="24" r="12" fill="#66bb6a"/><circle cx="40" cy="22" r="14" fill="#81c784"/><circle cx="34" cy="30" r="14" fill="#4caf50"/><rect x="28" y="34" width="8" height="20" fill="#8bc34a"/><circle cx="28" cy="28" r="3" fill="#000"/><circle cx="38" cy="26" r="3" fill="#000"/></svg>`),
  cherry: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="24" cy="40" r="10" fill="#e53935"/><circle cx="40" cy="40" r="10" fill="#c62828"/><path d="M24 18 C 26 6, 38 8, 40 18" stroke="#2e7d32" stroke-width="4" fill="none"/><circle cx="22" cy="42" r="3" fill="#000"/><circle cx="38" cy="42" r="3" fill="#000"/></svg>`),
  onion: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><ellipse cx="32" cy="40" rx="18" ry="20" fill="#ffe0b2" stroke="#6d4c41" stroke-width="3"/><path d="M28 14 C30 10, 34 10, 36 14" stroke="#8d6e63" stroke-width="3" fill="none"/><circle cx="28" cy="40" r="3" fill="#000"/><circle cx="36" cy="40" r="3" fill="#000"/></svg>`),
  grapes: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="28" cy="44" r="8" fill="#7e57c2"/><circle cx="36" cy="44" r="8" fill="#673ab7"/><circle cx="32" cy="36" r="8" fill="#9575cd"/><circle cx="24" cy="36" r="8" fill="#7e57c2"/><circle cx="40" cy="36" r="8" fill="#7e57c2"/><rect x="30" y="16" width="4" height="10" fill="#795548"/><circle cx="28" cy="34" r="2.5" fill="#000"/><circle cx="36" cy="42" r="2.5" fill="#000"/></svg>`),
  cornCannon: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect x="8" y="28" width="48" height="20" rx="6" fill="#4e342e"/><circle cx="52" cy="38" r="10" fill="#263238"/><rect x="10" y="18" width="24" height="10" fill="#8bc34a"/><rect x="12" y="12" width="20" height="6" fill="#cddc39"/></svg>`),
  onionTower: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect x="18" y="12" width="28" height="40" rx="6" fill="#ffe0b2" stroke="#6d4c41" stroke-width="3"/><circle cx="32" cy="24" r="6" fill="#bcaaa4"/><rect x="22" y="36" width="20" height="10" fill="#d7ccc8"/></svg>`),
  tower: 'data:image/svg+xml;base64,' + btoa(`<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="80" height="120"><rect x="10" y="20" width="60" height="90" rx="10" fill="#b0bec5" stroke="#455a64" stroke-width="4"/><rect x="20" y="34" width="40" height="20" fill="#90a4ae"/><circle cx="40" cy="84" r="8" fill="#cfd8dc"/></svg>`)
};
</script>

<script>
(() => {
'use strict';

/* ------------------ Settings & Globals ------------------ */
const DESIGN_W = 1024, DESIGN_H = 576; // internal logic
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
let scaleX = 1, scaleY = 1; // device scale for pointer mapping

const GROUND_Y = DESIGN_H * 0.62;
const LEFT_BASE_X = 120, RIGHT_BASE_X = DESIGN_W - 120;
const LANE_Y = GROUND_Y - 40;
const LANE_H = 80;
const MATCH_SECONDS = 180;

const MANA_MAX = 10, MANA_REGEN = 1;

let reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches || (Math.min(window.innerWidth, window.innerHeight) < 520);
let muted = false;
let particleBudget = Math.min(160, Math.max(60, Math.floor(window.innerWidth * window.devicePixelRatio / 6)));
if(reduceMotion) particleBudget = 50;

/* ------------------ UI refs ------------------ */
const timerEl = document.getElementById('timer');
const manaFill = document.getElementById('manaFill');
const manaText = document.getElementById('manaText');
const cardRow = document.getElementById('cardRow');
const toast = document.getElementById('toast');
const endScreen = document.getElementById('endScreen');
const endTitle = document.getElementById('endTitle');
const endSummary = document.getElementById('endSummary');
const restartBtn = document.getElementById('restartBtn');

document.getElementById('reduceMotionBtn').onclick = () => {
  reduceMotion = !reduceMotion;
  document.getElementById('reduceMotionBtn').textContent = 'Reduce Motion: ' + (reduceMotion ? 'On' : 'Off');
};

/* ------------------ Background Music ------------------ */
const bgmEl = new Audio('data:audio/wav;base64,UklGRlQeAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAACABAAZGF0YQweAAAAAAAAP///wAAAP///wAAAP7+/gAAAP7+/gAAAP///wAAAP///wAAAP7+/gAAAP7+/gAAAP///wAAAP///wAAAP7+/gAAAP7+/gAAAP///wAAAP///wAAAA==');
bgmEl.loop = true; bgmEl.volume = 0.28;
let bgm = bgmEl;
document.getElementById('muteBtn').onclick = () => {
  muted = !muted; bgm.volume = muted ? 0 : 0.28;
  document.getElementById('muteBtn').textContent = 'Mute: ' + (muted ? 'On' : 'Off');
};
document.addEventListener('pointerdown', () => { bgm.play().catch(()=>{}); }, {once:true});

/* ------------------ WebAudio SFX ------------------ */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
function beep(freq=440, dur=0.08, type='square', gain=0.03){
  if(muted) return;
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t0);
  g.gain.setValueAtTime(g.gain.value, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
  osc.stop(t0 + dur + 0.02);
}
const sfx = {
  deploy(){ beep(660, .05, 'sine', .05); },
  hit(){ beep(220, .03, 'square', .03); },
  big(){ beep(140, .12, 'sawtooth', .06); },
  spell(){ beep(520, .08, 'triangle', .05); },
  crown(){ beep(880, .2, 'sine', .06); }
};

/* ------------------ Pointer helpers ------------------ */
function getCanvasPos(ev){
  const rect = cvs.getBoundingClientRect();
  // Map client to internal design coords
  const x = (ev.clientX - rect.left) * (DESIGN_W / rect.width);
  const y = (ev.clientY - rect.top)  * (DESIGN_H / rect.height);
  return {x,y};
}
function inCanvas(ev){
  const r = cvs.getBoundingClientRect();
  return ev.clientX>=r.left && ev.clientX<=r.right && ev.clientY>=r.top && ev.clientY<=r.bottom;
}

/* ------------------ RNG ------------------ */
const rng = {
  seed: 1337,
  next(){ this.seed = (this.seed * 1664525 + 1013904223) >>> 0; return this.seed / 0xFFFFFFFF; },
  range(a,b){ return a + (b-a)*this.next(); },
  pick(arr){ return arr[(this.next()*arr.length)|0]; }
};

/* ------------------ Easing & Tweens ------------------ */
const Ease = {
  outCubic: t => 1 - Math.pow(1-t, 3),
  inOutQuad: t => t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2,
  outBack: t => { const c1=1.70158, c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); }
};
const Tweens = [];
function tween(obj, prop, to, dur=300, ease=Ease.outCubic){
  const from = obj[prop];
  const start = performance.now();
  const tw = { obj, prop, from, to, dur, ease, start, done:false };
  Tweens.push(tw);
  return tw;
}
function updateTweens(now){
  for(let i=Tweens.length-1;i>=0;i--){
    const t = Tweens[i];
    const el = Math.min(1, (now - t.start) / t.dur);
    const v = t.from + (t.to - t.from) * t.ease(el);
    t.obj[t.prop] = v;
    if(el>=1){ Tweens.splice(i,1); t.done=true; }
  }
}

/* ------------------ Entities & Data ------------------ */
const Types = { TROOP:'troop', SPELL:'spell', BUILD:'build', TOWER:'tower', PROJECTILE:'proj' };
const Cards = [
  {key:'banana', name:'Banana Bomber', type:Types.TROOP, cost:3},
  {key:'carrot', name:'Carrot Cavalry', type:Types.TROOP, cost:4},
  {key:'tomato', name:'Tomato Catapult', type:Types.TROOP, cost:5},
  {key:'pineapple', name:'Pineapple Puncher', type:Types.TROOP, cost:2},
  {key:'broccoli', name:'Broccoli Bruiser', type:Types.TROOP, cost:6},
  {key:'cherry', name:'Cherry Chucker', type:Types.TROOP, cost:3},
  {key:'onion', name:'Onion Assassin', type:Types.TROOP, cost:4},
  {key:'grapes', name:'Grape Swarm', type:Types.TROOP, cost:2},
  {key:'lettuce', name:'Lettuce Shield', type:Types.SPELL, cost:3},
  {key:'pepper', name:'Hot Pepper Blast', type:Types.SPELL, cost:4},
  {key:'watermelon', name:'Watermelon Wave', type:Types.SPELL, cost:5},
  {key:'cornCannon', name:'Corn Cannon', type:Types.BUILD, cost:4},
  {key:'onionTower', name:'Onion Tower', type:Types.BUILD, cost:5},
];
const Stats = {
  troops: {
    banana:{hp:250, dmg:80, range:90, splash:true, speed:40},
    carrot:{hp:350, dmg:90, range:25, splash:false, speed:70},
    tomato:{hp:400, dmg:120, range:140, splash:true, speed:28},
    pineapple:{hp:180, dmg:60, range:25, splash:false, speed:50},
    broccoli:{hp:800, dmg:140, range:25, splash:false, speed:24},
    cherry:{hp:220, dmg:40, range:70, splash:true, multishot:3, speed:42},
    onion:{hp:250, dmg:160, range:25, splash:false, speed:90, prefersRanged:true},
    grapes:{hp:60, dmg:20, range:20, splash:false, speed:78, count:6},
  },
  spells: {
    lettuce:{hpBoost:0.5, dur:5000, radius:80},
    pepper:{damage:200, radius:70},
    watermelon:{damage:150, width:30}
  },
  builds: {
    cornCannon:{hp:600, dmg:70, range:200, rate:1.1},
    onionTower:{hp:800, dmg:50, range:140, rate:0.5, poison:true}
  },
  towers: {
    side:{hp:1300, dmg:40, range:160, rate:0.9},
    king:{hp:2200, dmg:60, range:180, rate:0.8}
  }
};

/* ------------------ Image cache ------------------ */
const loadedImgs = {};
async function ensureImages(){
  const keys = Object.keys(SVGs);
  for(const k of keys){
    if(loadedImgs[k]) continue;
    loadedImgs[k] = await new Promise(res => {
      const im = new Image();
      im.onload=()=>res(im);
      im.src = SVGs[k];
    });
  }
}

/* ------------------ Game State ------------------ */
const state = {
  time: MATCH_SECONDS,
  player: { mana:5, crowns:0, hand:[], deck:[], side:'left' },
  enemy:  { mana:5, crowns:0, hand:[], deck:[], side:'right' },
  ents: [],
  projs: [],
  particles: [],
  toasts: 0,
  shake: 0,
  running: true
};

/* ------------------ Utils ------------------ */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);

function showToast(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  state.toasts++;
  setTimeout(()=>{
    state.toasts--;
    if(state.toasts<=0) toast.classList.remove('show');
  }, 1200);
}

/* ------------------ Deck & Hands ------------------ */
function buildDeck(){
  const base = Cards.slice(0);
  for(let i=base.length-1;i>0;i--){
    const j = (rng.next()* (i+1))|0; [base[i], base[j]] = [base[j], base[i]];
  }
  return base;
}
function drawCard(side){
  const p = state[side];
  if(p.deck.length===0) p.deck = buildDeck();
  const c = p.deck.pop();
  p.hand.push(c);
  if(p.hand.length>4) p.hand.shift();
}
function initHands(){
  state.player.deck = buildDeck();
  state.enemy.deck  = buildDeck();
  for(let i=0;i<4;i++){ drawCard('player'); drawCard('enemy'); }
}

/* ------------------ Entities ------------------ */
let entId = 1;
function spawnTower(side, kind){
  const x = side==='left' ? (kind==='king'? LEFT_BASE_X : LEFT_BASE_X+ (kind==='sideL'? -40:40))
                          : (kind==='king'? RIGHT_BASE_X : RIGHT_BASE_X+ (kind==='sideL'? -40:40));
  const y = LANE_Y - 60 + (kind==='king'? -10:0);
  const st = Stats.towers[kind==='king'?'king':'side'];
  const e = { id:entId++, type:Types.TOWER, side, x, y, w:60, h:90, hp:st.hp, hpMax:st.hp, dmg:st.dmg, rng:st.range, rate:st.rate, atkCd:0, dead:false, king:kind==='king', icon:'tower', wound:st.hp, shield:0, shieldUntil:0 };
  state.ents.push(e);
  return e;
}
function basicTroop(key, side, x,y){
  const t = Stats.troops[key];
  return { id:entId++, type:Types.TROOP, key, side, x, y, w:42, h:42, hp:t.hp, hpMax:t.hp, dmg:t.dmg, rng:t.range, speed:t.speed* (side==='left'?1:-1), splash:!!t.splash, multishot:t.multishot||1, prefersRanged:!!t.prefersRanged, dead:false, atkCd:0, target:null, wound:t.hp, shield:0, shieldUntil:0, icon:key };
}
function spawnTroop(key, side, x,y){
  const spec = Stats.troops[key];
  if(key==='grapes'){
    for(let i=0;i<spec.count;i++){
      const ox = (rng.range(-20,20));
      const oy = (rng.range(-10,10));
      state.ents.push(basicTroop(key, side, x+ox, y+oy));
    }
  } else {
    state.ents.push(basicTroop(key, side, x, y));
  }
}
function spawnBuild(key, side, x, y){
  const st = Stats.builds[key];
  const e = { id:entId++, type:Types.BUILD, key, side, x, y, w:48, h:48, hp:st.hp, hpMax:st.hp, dmg:st.dmg, rng:st.range, rate:st.rate, atkCd:0, dead:false, poison:!!st.poison, wound:st.hp, icon:key, shield:0, shieldUntil:0 };
  state.ents.push(e);
  return e;
}
function projectile(from, toX, toY, dmg, splash=false, color='#fff'){
  const ang = Math.atan2(toY-from.y, toX-from.x), spd = 220;
  state.projs.push({ fromId:from.id, x:from.x, y:from.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, dmg, splash, color, ttl:2000 });
}
function applyDamage(e, dmg){
  const now = performance.now();
  if(e.shield > 0 && now < e.shieldUntil){
    const absorbed = Math.min(dmg, e.shield);
    e.shield -= absorbed; dmg -= absorbed;
  }
  if(dmg<=0) return;
  e.hp -= dmg;
  e.wound = Math.max(0, e.wound - dmg*0.6);
  sfx.hit();
  spawnHitParticles(e.x, e.y, dmg>100?'#ffd54f':'#fff');
  if(e.hp<=0 && !e.dead){
    e.dead = true;
    for(let i=0;i<10;i++) spawnParticle(e.x, e.y, '#000', 600);
  }
}
function damageArea(cx, cy, radius, dmg, friendlySide){
  let hits=0;
  for(const e of state.ents){
    if(e.dead || e.side===friendlySide) continue;
    if(dist({x:cx,y:cy}, e) <= radius){
      applyDamage(e, dmg); hits++;
    }
  }
  return hits;
}

/* ------------------ Spells ------------------ */
function castSpell(key, side, x,y){
  if(key==='lettuce'){
    const st=Stats.spells.lettuce;
    const until = performance.now() + st.dur;
    for(const e of state.ents){
      if(e.dead || e.side!==side) continue;
      if(dist({x,y}, e) <= st.radius){
        const extra = e.hpMax * st.hpBoost;
        e.shield = Math.max(e.shield||0, extra);
        e.shieldUntil = until;
        for(let i=0;i<10;i++) spawnParticle(e.x, e.y, '#8bc34a', 700);
      }
    }
    sfx.spell();
  }
  if(key==='pepper'){
    const st=Stats.spells.pepper;
    const hits = damageArea(x,y, st.radius, st.damage, side);
    for(let i=0;i<20;i++) spawnParticle(x, y, '#ff7043', 800);
    if(hits>2) shake(5, 180);
    sfx.spell();
  }
  if(key==='watermelon'){
    const st=Stats.spells.watermelon;
    const dir = side==='left'? 1 : -1;
    for(const e of state.ents){
      if(e.dead || e.side===side) continue;
      if(Math.abs(e.y - y) < 40 && ((dir>0 && e.x>=x) || (dir<0 && e.x<=x))){
        applyDamage(e, st.damage);
      }
    }
    for(let i=0;i<14;i++) spawnParticle(x, y, '#66bb6a', 650);
    shake(4, 140);
    sfx.spell();
  }
}

/* ------------------ Targeting ------------------ */
function findNearestEnemy(e){
  let nearest=null, dmin=1e9;
  for(const o of state.ents){
    if(o.dead || o.side===e.side) continue;
    const d = dist(e,o);
    if(d<dmin){ dmin=d; nearest=o; }
  }
  return {nearest, dmin};
}

/* ------------------ AI ------------------ */
let aiTimer = 0;
function aiUpdate(dt){
  const ai = state.enemy;
  aiTimer -= dt;
  if(aiTimer>0) return;

  const underAttack = state.ents.some(e => e.side==='right' && e.type!=='tower' && !e.dead && e.x>DESIGN_W*0.6);
  const pushReady = ai.mana >= 5;

  const playables = ai.hand.filter(c => c.cost <= ai.mana);
  if(playables.length===0){ aiTimer = 0.7; return; }

  let card;
  if(underAttack){
    card = playables.find(c => c.type==='build') ||
           playables.find(c => c.key==='tomato' || c.key==='banana' || c.key==='cherry') ||
           rng.pick(playables);
  }else if(pushReady){
    card = playables.find(c => ['carrot','onion','pineapple'].includes(c.key)) || rng.pick(playables);
  }else{
    card = rng.pick(playables);
  }

  const x = RIGHT_BASE_X - 40 - rng.range(0,30);
  const y = LANE_Y + rng.range(-LANE_H/2, LANE_H/2);
  playCard('enemy', card, x, y);
  aiTimer = rng.range(0.9, 1.5);
}

/* ------------------ Particles & Shake ------------------ */
function spawnParticle(x,y,color='#fff', life=600){
  if(state.particles.length > particleBudget) return;
  const a = rng.range(0, Math.PI*2);
  const s = rng.range(40, 120);
  state.particles.push({x,y,vx:Math.cos(a)*s, vy:Math.sin(a)*s, life, t:0, color});
}
function spawnHitParticles(x,y,color){
  const n = reduceMotion ? 4 : 8;
  for(let i=0;i<n;i++) spawnParticle(x,y,color, 500);
}
function updateParticles(dt){
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    p.t += dt;
    p.x += p.vx * dt/1000;
    p.y += p.vy * dt/1000;
    p.vy += 220 * dt/1000;
    if(p.t>=p.life) state.particles.splice(i,1);
  }
}
function shake(amp, dur){
  if(reduceMotion) return;
  state.shake = Math.max(state.shake, amp);
  setTimeout(()=> state.shake=0, dur);
}

/* ------------------ Rendering ------------------ */
const imgKeys = { banana:'banana', carrot:'carrot', tomato:'tomato', pineapple:'pineapple', broccoli:'broccoli', cherry:'cherry', onion:'onion', grapes:'grapes', cornCannon:'cornCannon', onionTower:'onionTower', tower:'tower' };

function drawEntity(e){
  const im = loadedImgs[e.icon] || loadedImgs.tower;
  const w = e.w, h=e.h;
  const x = e.x - w/2, y = e.y - h/2;
  ctx.save();
  if(!reduceMotion){
    const bob = Math.sin(performance.now()/200 + e.id) * 1.3;
    ctx.translate(0, bob);
  }
  ctx.drawImage(im, x, y, w, h);
  // health bar
  const barW = w, barH = 6;
  const hpPct = clamp(e.hp/e.hpMax, 0,1);
  const woundPct = clamp(e.wound/e.hpMax, 0,1);
  ctx.fillStyle='#000000aa';
  ctx.fillRect(x, y-10, barW, barH);
  ctx.fillStyle='#d32f2f';
  ctx.fillRect(x, y-10, barW * woundPct, barH);
  ctx.fillStyle='#66bb6a';
  ctx.fillRect(x, y-10, barW * hpPct, barH);
  if(e.shield>0 && performance.now() < e.shieldUntil){
    ctx.strokeStyle='#8bc34a'; ctx.lineWidth=2;
    ctx.strokeRect(x-2, y-12, barW+4, barH+4);
  }
  ctx.restore();
}

function drawParticles(){
  for(const p of state.particles){
    const a = 1 - p.t / p.life;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2 + 2*a, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawArena(){
  const gTop = GROUND_Y - 18, gBot = DESIGN_H;
  const grad = ctx.createLinearGradient(0,gTop, 0,gBot);
  grad.addColorStop(0, '#6fb96f'); grad.addColorStop(1, '#4c8b4c');
  ctx.fillStyle = grad;
  ctx.fillRect(0,gTop, DESIGN_W, gBot-gTop);
  ctx.fillStyle='#e8f5e980';
  ctx.fillRect(0, LANE_Y-2, DESIGN_W, 4);
  if(!reduceMotion){
    const t = performance.now()/1000;
    ctx.fillStyle='#5aa35a';
    for(let i=0;i<16;i++){
      const x = (i*64 + (Math.sin(t+i)*6)) % DESIGN_W;
      ctx.fillRect(x, GROUND_Y-8, 40, 6);
    }
  }
}

/* ------------------ Logic ------------------ */
function stepEntity(e, dt){
  if(e.dead) return;
  e.wound = Math.max(e.hp, e.wound - dt* (e.hpMax/1500));

  if(e.type==='troop'){
    const {nearest, dmin} = findNearestEnemy(e);
    if(nearest){
      if(dmin > e.rng - 4){
        e.x += (e.speed) * dt/1000;
        e.y = clamp(e.y, LANE_Y - LANE_H/2, LANE_Y + LANE_H/2);
      }else{
        e.atkCd -= dt/1000;
        if(e.atkCd<=0){
          e.atkCd = 1.0;
          if(e.splash || e.multishot>1){
            for(let i=0;i<e.multishot;i++){
              projectile(e, nearest.x, nearest.y, e.dmg, e.splash, '#fff');
            }
          }else{
            applyDamage(nearest, e.dmg);
          }
        }
      }
    }else{
      e.x += (e.speed) * dt/1000;
    }
  } else if(e.type==='tower' || e.type==='build'){
    e.atkCd -= dt/1000;
    if(e.atkCd<=0){
      const enemies = state.ents.filter(o => !o.dead && o.side!==e.side && dist(e,o) <= e.rng);
      if(enemies.length){
        e.atkCd = (e.rate || 1);
        const t = enemies.sort((a,b)=>a.hp-b.hp)[0];
        if(e.poison){ applyDamage(t, e.dmg); }
        else { projectile(e, t.x, t.y, e.dmg, false, '#ffd54f'); }
      }
    }
  }
}

function resolveProjectiles(dt){
  for(let i=state.projs.length-1;i>=0;i--){
    const p = state.projs[i];
    p.ttl -= dt;
    p.x += p.vx * dt/1000;
    p.y += p.vy * dt/1000;
    let hit=null, dmin=1e9;
    for(const e of state.ents){
      if(e.dead) continue;
      const me = state.ents.find(z=>z.id===p.fromId);
      if(me && e.side===me.side) continue;
      const d = dist(p,e);
      if(d < 28 && d < dmin){ dmin=d; hit=e; }
    }
    if(p.ttl<=0 || hit){
      if(hit){
        if(p.splash){
          damageArea(hit.x, hit.y, 60, p.dmg, state.ents.find(z=>z.id===p.fromId)?.side);
          shake(3, 120);
        }else{
          applyDamage(hit, p.dmg);
        }
      }
      state.projs.splice(i,1);
    }
  }
}

/* ------------------ Card Play ------------------ */
function playCard(side, card, x,y){
  const p = state[side];
  if(card.cost > p.mana){ if(side==='player') showToast('Not enough mana!'); return false; }
  p.mana -= card.cost;
  manaText.textContent = `${Math.floor(state.player.mana)} / ${MANA_MAX}`;
  if(side==='player') sfx.deploy();

  if(card.type==='troop'){
    spawnTroop(card.key, side, x,y);
  } else if(card.type==='build'){
    spawnBuild(card.key, side, x,y);
  } else if(card.type==='spell'){
    castSpell(card.key, side, x,y);
  }
  const hand = p.hand;
  const idx = hand.indexOf(card);
  if(idx>=0){ hand.splice(idx,1); }
  drawCard(side);
  if(side==='player') buildHandUI();
  return true;
}

/* ------------------ Towers & Setup ------------------ */
function setup(){
  initHands();
  spawnTower('left','sideL');  spawnTower('left','sideR');  spawnTower('left','king');
  spawnTower('right','sideL'); spawnTower('right','sideR'); spawnTower('right','king');
}

function endMatch(playerWon){
  if(!state.running) return;
  state.running=false;
  endTitle.textContent = playerWon? 'Victory!':'Defeat';
  endSummary.textContent = `You ${state.player.crowns} ‚Äî ${state.enemy.crowns} AI`;
  endScreen.style.display='flex';
  sfx.crown();
}

restartBtn.onclick = () => {
  Object.assign(state, { time:MATCH_SECONDS, player:{ mana:5, crowns:0, hand:[], deck:[], side:'left' }, enemy:{ mana:5, crowns:0, hand:[], deck:[], side:'right' }, ents:[], projs:[], particles:[], toasts:0, shake:0, running:true });
  endScreen.style.display='none';
  setup(); buildHandUI();
};

/* ------------------ HUD & Hand ------------------ */
function buildHandUI(){
  cardRow.innerHTML='';
  const hand = state.player.hand;
  hand.forEach(card => {
    const el = document.createElement('div');
    el.className='card';
    if(card.cost>state.player.mana) el.classList.add('disabled');
    el.innerHTML = `<div class="cardTitle">${card.name}</div><div class="cost">‚ú¶ ${card.cost}</div>`;
    el.style.backgroundImage = `url(${SVGs[card.icon || card.key] || SVGs.tower})`;
    el.style.backgroundRepeat='no-repeat';
    el.style.backgroundPosition='center 60%';
    el.style.backgroundSize='64px 64px';

    let dragging=false;
    let ghost=null;

    const onMove=(ev)=>{
      if(!dragging) return;
      ev.preventDefault();
      const {x,y} = getCanvasPos(ev);
      if(ghost){
        const rect = cvs.getBoundingClientRect();
        ghost.style.left = (rect.left + (x * rect.width / DESIGN_W) - 40)+'px';
        ghost.style.top  = (rect.top  + (y * rect.height/ DESIGN_H) - 40)+'px';
      }
    };
    const onUp=(ev)=>{
      if(!dragging) return;
      dragging=false;
      document.removeEventListener('pointermove', onMove, {passive:false});
      document.removeEventListener('pointerup', onUp);
      el.classList.remove('dragging');
      if(ghost){ document.body.removeChild(ghost); ghost=null; }
      if(!inCanvas(ev)){ showToast('Drop inside the battlefield.'); buildHandUI(); return; }
      const {x,y} = getCanvasPos(ev);
      if(x < DESIGN_W*0.6){
        playCard('player', card, x, clamp(y, LANE_Y-LANE_H/2, LANE_Y+LANE_H/2));
      }else{
        showToast('Drop on your side (left).');
      }
      buildHandUI();
    };
    el.onpointerdown = (ev)=>{
      if(card.cost>state.player.mana){ showToast('Not enough mana!'); return; }
      dragging=true;
      el.classList.add('dragging');
      ghost = document.createElement('div');
      ghost.style.position='fixed';
      ghost.style.width='80px'; ghost.style.height='80px';
      ghost.style.border='2px dashed #fff8';
      ghost.style.borderRadius='10px';
      ghost.style.pointerEvents='none';
      ghost.style.transform='translateZ(0)';
      document.body.appendChild(ghost);
      document.addEventListener('pointermove', onMove, {passive:false});
      document.addEventListener('pointerup', onUp);
      onMove(ev);
    };
    cardRow.appendChild(el);
  });
}

function updateHUD(){
  manaText.textContent = `${Math.floor(state.player.mana)} / ${MANA_MAX}`;
  manaFill.style.width = `${(state.player.mana/MANA_MAX)*100}%`;
}

/* ------------------ Resize handling ------------------ */
function onResize(){
  // Canvas element auto scales via CSS aspect-ratio;
  // we only need clientRect for pointer mapping, handled in getCanvasPos.
}
window.addEventListener('resize', onResize);

/* ------------------ Game Loop ------------------ */
let last = performance.now();
function loop(){
  const t = performance.now();
  let dt = t - last; if(dt>60) dt=60; last = t;
  if(!state.running){ requestAnimationFrame(loop); return; }

  state.player.mana = clamp(state.player.mana + MANA_REGEN * dt/1000, 0, MANA_MAX);
  state.enemy.mana  = clamp(state.enemy.mana  + MANA_REGEN * dt/1000, 0, MANA_MAX);
  updateHUD();

  aiUpdate(dt);

  for(const e of state.ents) stepEntity(e, dt);
  resolveProjectiles(dt);
  updateParticles(dt);

  // remove dead & crowns
  for(let i=state.ents.length-1;i>=0;i--){
    const e = state.ents[i];
    if(e.dead){
      if(e.type==='tower' && e.king){
        if(e.side==='right') state.player.crowns++; else state.enemy.crowns++;
        sfx.big(); sfx.crown();
        endMatch(e.side==='right');
      }
      state.ents.splice(i,1);
    }
  }

  state.time -= dt/1000;
  if(state.time<=0){
    endMatch(state.player.crowns >= state.enemy.crowns);
  }
  const mm = Math.max(0, Math.floor(state.time/60));
  const ss = Math.max(0, Math.floor(state.time%60));
  timerEl.textContent = `${mm}:${ss.toString().padStart(2,'0')}`;

  // draw
  ctx.save();
  if(state.shake && !reduceMotion){
    ctx.translate(rng.range(-state.shake,state.shake), rng.range(-state.shake,state.shake));
  }
  ctx.clearRect(0,0,DESIGN_W,DESIGN_H);
  drawArena();
  const sorted = state.ents.slice().sort((a,b)=>a.y-b.y);
  for(const e of sorted) drawEntity(e);
  drawParticles();
  ctx.restore();

  requestAnimationFrame(loop);
}

/* ------------------ Boot ------------------ */
(async function boot(){
  await ensureImages();
  setup(); buildHandUI();
  requestAnimationFrame(loop);
})();

})(); // IIFE
</script>
</body>
</html>
